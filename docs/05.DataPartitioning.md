## Data Partitioning
- 데이터 파티셔닝은 큰 데이터베이스를 수 많은 작은 부분으로 나누는 기술이다.
- 응용프로그램의 관리성, 성능, 가용성 및 로드 밸런싱을 향상시키기 위해 `DB 테이블을 여러 컴퓨터에 걸쳐 분할하는 과정`이다.
- 데이터 파티셔닝의 당위성은 
  일정 규모 시점 이후 `beefier 서버를 추가해 수직적으로 성장하는 것`보다 `더 많은 서버를 추가하여 수평적으로 확장하는 것이 저렴`하고 실현 가능성이 높다.
  
### 1. Partitioning Methods
- 데이터베이스를 여러 개의 작은 DB로 분할하는 방법을 결정하기 위해 사용할 수 있는 여러 가지 방법
- 대규모 어플리케이션에서 사용하는 가장 인기 있는 세 가지
    1. `Horizontal partitioning`
        - `이 방법은 다른 row를 다른 table에 넣는 방식`이다.
        - 우리가 테이블에 다른 장소들을 저장할 때, zip 코드가 10000 미만인 장소들은 하나의 테이블에, 
          10000보다 큰 장소들은 별도의 테이블에 저장되도록 결정할 수 있다.
        - 위 예시와 같은 방식을 범위 기반 파티셔닝(a range based partitioning) 라 한다.
        - 서로 다른 범위의 데이터를 별도의 테이블에 저장하고 있기 때문이다.
        - Horizontal partitioning는 Data Sharding 이라고도 불린다.
        
        - `이 방법의 주요 문제점`은 `파티셔닝에 사용되는 범위를 신중하게 선택하지 않으면` 파티셔닝 방식이 서버의 불균형을 초래한다는 것이다.
        - 예로 우편 번호에 따라 위치를 분할하게 되면 다른 우편 번호에 걸쳐 장소가 고르게 분포될 것으로 가정하지만 
          교외 도시에 비해 인구가 밀집한 지역에 많은 장소가 있을 수 있기 때문에 타당하지 않다.

    2. `Vertical Partitioning`
        - 스키마(schema)와 서버간의 특정한 `특징과 관련된 데이터를 테이블에 저장하는 방식`.
        - 예를 들어 인스타그램과 같은 어플리케이션을 만든다고 할때
            - 사용자 프로필 데이터, 업로드된 사진 정보, 팔로우정보가 제공되는 경우 
              사용자 프로필 정보를 DB서버 하나, 친구 목록을 다른 서버에, 사진을 또 다른 서버에 배치하도록 결정할 수 있다.
        - 수직 파티셔닝은 구현이 간편하고 애플리케이션에 미치는 영향이 적다.

        - `이 접근 방식의 주요 문제점`는 `애플리케이션이 추가적인 성장을 하려는 경우` 다양한 서버에 걸쳐 특정 기능 DB를 추가로 분할해야 할 수도 있다는 점이다.
        - 예시: 1억 4천만명 사용자가 100억장의 사진에 대한 모든 메타 데이터 쿼리를 `단일 서버가 처리할 수 없을 것`이다. 
      
    3. `Directory Based Partitioning`
        - 위에서 언급된 문제를 해결하기 위해 느슨하게 연결된 접근법은 현재의 파티셔닝 계획을 알고 DB 엑세스 코드에서 이를 추출하는 Lookup Service를 만드는 것이다.
        - 특정 데이터 엔티티가 어디에 있는지 확인하기 위해 DB서버에 대한 각 튜플 키 간의 매핑을 보관하는 디렉터리 서버를 쿼리한다.
        - 이렇게 느슨하게 연결된 접근 방식은 응용프로그램에 영향을 미치지 않고 DB 풀에 서버를 추가하거나 파티셔닝 계획을 변경하는 것과 같은 작업을 수행할 수 있다는 것을 의미한다.

### 2. Partitioning Criteria
1. `Key or Hash-based partitioning`
    - 스키마에서 저장 중인 엔티티의 `주요 키 값`을 `해시 함수`를 적용하여 `파티션 번호`를 산출한다.
    - 예를들어, 만약 n개의 DB 서버를 가지고 있고, 우리의 ID는 `새로운 레코드를 삽입할 때마다 1씩 증가하는` 숫자 값이다.
        - 해시함수는 `'ID % n'`이 될 수 있으며, 해당 레코드를 저장/읽을 수 있는 `서버 번호`를 우리에게 줄 것이다.

    - 이 접근방식은 서버 간에 균일한 데이터 할당을 보장해야 한다.
    - `이 접근방식의 근본적인 문제`는 새로운 서버를 추가할 때 DB 서버의 전체 수를 효과적으로 수정해야 한다. 
        - 이유는 `해시함수를 변경`해서 서비스를 위한 일관성있는 데이터 재분배와 다운타임이 필요하기 때문이다.
    - 해당 `문제에 대한 해결책`은 `일관성있는 해싱`을 사용해야 한다.

2. `List partitioning`
    - 스키마에 각 파티션에 값 목록이 할당되므로, 새 레코드를 삽입하고 싶을 때마다 어떤 파티션에 키가 들어 있는지 확인한 다음 거기에 저장하는 방식이다.
    - 예를 들어, 아이슬란드, 노르웨이, 스웨덴, 핀란드 또는 덴마크에 살고 있는 모든 사용자들이 북유럽 국가들을 위한 파티션에 저장할 수 있다.
    
3. `Round-robin partitioning`
    - 균일한 데이터 분포를 보장하는 매우 간단한 전략이다.
    - 'n' 파티션에서 'i' 튜플은 파티션(i mod n)에 할당된다.

4. `Composite partitioning`
    - 분할 스키마들 중 하나를 새로운 스키마를 고안하여 결합하는 방법이다.
    - 예를 들어 먼저 `목록 분할 방식(a list partitioning scheme)`을 적용한 다음 `해시 기반 분할(hash based partitioning)`을 적용하십시오.
    - `일관된 해싱(Consistent hashing)`은 해시가 키 공간을 나열할 수 있는 크기로 줄이는 `해시와 목록 분할`의 합성어로 간주할 수 있다.

### 3. Common Problems of Data Partitioning
- `분할된 데이터베이스`에서는 수행할 수 있는 다른 작업에 대한 `특정한 추가 제약`이 있다.
- 이러한 제약조건의 여러 테이블 또는 동일한 테이블에 있는 여러 행에 걸친 `작업`이 `동일한 서버`에서 더 이상 실행되지 않기 때문이다.
  
- 파티셔닝으로 인해 발생하는 몇 가지 제약 및 추가 복잡성
    1. `Joins and Denormalization(조인과 비정규화)`
        - 한 서버에서 실행중인 데이터베이스에서 `조인`을 수행하는 것은 간단하다.
        - 하지만 일단 데이터베이스가 분할되고 여러 시스템에 분산되면 데이터베이스 파티션에 걸쳐있는 조인을 수행하는 것이 불가능한 경우가 많다.
        - 이러한 `조인`은 여러 서버에서 데이터를 컴파일 해야하므로 `성능 효율성이 떨어진다`.
        - 이 문제에 대한 `일반적인 해결 방법`은 이전에 조인이 필요했던 쿼리를 단일 테이블에서 수행 할 수 있도록 `데이터베이스를 비정규화`하는 것이다. 
        - 물론 이제 서비스는 `데이터 불일치`와 같은 `비정규화`로 인한 모든 위험을 처리해야한다.

    2. `Referential integrity(참조 무결성)`
        - 파티션 된 데이터베이스에서 `파티션 간 쿼리를 수행`하는 것이 `불가능`하다는 것을 확인
        - 마찬가지로 파티션 된 데이터베이스에서 `외래 키`와 같은 `데이터 무결성 제약 조건`을 적용하려는 시도는 매우 어려울 수 있다.
        - 대부분의 RDBMS는 `서로 다른 데이터베이스 서버`의 데이터베이스에서 외래 키 제약 조건을 지원하지 않는다.
        - 즉, 파티션 된 데이터베이스에서 참조 무결성이 필요한 응용 프로그램은 응용 프로그램 `코드에서 적용`해야하는 경우가 많습니다.

    3. `Rebalancing(재조정)`
        - 파티션 스키마를 변경하는 이유
            - 데이터 분배가 균일하지 않다. 예를 들어 하나의 데이터베이스 파티션에 맞지 않은 특정 우편번호에 대한 많은 정보가 있다. -> 데이터가 한쪽으로 쏠릴 수 있음
            - 파티션에 많은 부하가 있다. 예를 들어 사용자 사진 전용 DB 파티션에서 처리중인 요청이 너무 많을 수 있다.
        - 위와 같은 문제가 발생하는 경우, `더 많은 DB 파티션을 생성`하거나 `기존 파티션을 다시 조정`해야 한다. 
          즉, 파티셔닝 체계가 변경되고 모든 기존 데이터가 새 위치로 이동된다.
        - 다운 타임 없이 작업을 수행하는 것은 매우 어려운 일이다.
        - 디렉토리 기반 파티셔닝과 같은 체계를 사용하면 시스템의 복잡성을 증가시키고,
          새로운 단일 장애 지점을 생성하는 비용으로 보다 입맛에 맞는 환경을 `재조정`할 수 있습니다.
